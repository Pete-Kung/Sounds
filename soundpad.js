
function createPad(sound) {
    const pad = document.createElement("div");
    pad.classList.add("pad");
    pad.innerText = sound.name;
    pad.dataset.playing = "false";
    pad.buffer = null;
    pad.source = null;

    loadBuffer(`./sounds/${sound.file}`).then((buffer) => {
        pad.buffer = buffer;
    });

    const container = document.getElementById(sound.container);

    if (sound.container === "fxContainer") {
        // ‡πÅ‡∏ö‡∏ö "‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô loop / ‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î"
        pad.addEventListener("mousedown", () => {
            if (pad.dataset.playing !== "true") {
                queueStartPadFx(pad);
            }
        });
        pad.addEventListener("mouseup", () => {
            if (pad.dataset.playing === "true") {
                stopPadFx(pad);
            }
        });

        // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
        pad.addEventListener("touchstart", () => {
            if (pad.dataset.playing !== "true") {
                queueStartPadFx(pad);
            }
        });
        pad.addEventListener("touchend", () => {
            if (pad.dataset.playing === "true") {
                stopPadFx(pad);
            }
        });
    } else {
        // ‡∏õ‡∏∏‡πà‡∏°‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ä‡πâ click toggle ‡∏õ‡∏Å‡∏ï‡∏¥
        pad.addEventListener("click", () => {
            const currentlyPlayingPad = container.querySelector(".pad[data-playing='true']");
            if (currentlyPlayingPad && currentlyPlayingPad !== pad) {
                stopPad(currentlyPlayingPad);
            }

            if (pad.dataset.playing === "true") {
                stopPad(pad);
            } else {
                queueStartPad(pad);
            }
        });
    }

    container.appendChild(pad);
}

sounds.forEach(createPad);

function queueStartPadFx(pad) {
    const nextBarTime = audioContext.currentTime; // ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á sync
    const source = audioContext.createBufferSource();
    const gainNode = audioContext.createGain();

    source.buffer = pad.buffer;
    source.loop = pad.parentElement.id !== "fxContainer"; // fxContainer ‡πÑ‡∏°‡πà loop

    source.connect(gainNode);
    gainNode.connect(audioContext.destination);

    pad.source = source;
    pad.gainNode = gainNode;

    gainNode.gain.setValueAtTime(1, nextBarTime);
    source.start(nextBarTime);

    pad.dataset.playing = "true";
    pad.classList.add("active");

    // ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏°‡∏µ pendingStopTime ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô
    pad.pendingStopTime = null;
    pad._startTime = nextBarTime; // üïí ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°
}
function stopPadFx(pad) {
    if (pad.source && pad.gainNode) {
        const now = audioContext.currentTime;
        const holdDuration = now - (pad._startTime || now); // üïí ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡∏ô‡∏≤‡∏ô‡πÅ‡∏Ñ‡πà‡πÑ‡∏´‡∏ô

        pad.gainNode.gain.setValueAtTime(pad.gainNode.gain.value, now);
        pad.gainNode.gain.linearRampToValueAtTime(0, now + 0.05); // fade out

        pad.source.stop(now + 0.05);
        pad.pendingStopTime = now + 0.05;
        pad.dataset.playing = "false";
        pad.classList.remove("active");

        setTimeout(() => {
            try {
                pad.source?.disconnect?.();
                pad.gainNode?.disconnect?.();
            } catch (e) {
                console.warn("disconnect error", e);
            }
            pad.source = null;
            pad.gainNode = null;
            pad.pendingStopTime = null;
            pad._startTime = null;
            pad.classList.remove("active");

        }, 100); // cleanup ‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏¢‡∏∏‡∏î
    }
}
// ‡∏™‡∏£‡πâ‡∏≤‡∏á GainNode ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏£‡∏ß‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
const mainGainNode = audioContext.createGain();
mainGainNode.connect(audioContext.destination); // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö output ‡∏Ç‡∏≠‡∏á audioContext
console.log(mainGainNode);

function queueStartPad(pad) {
    const container = document.getElementById(pad.parentElement.id);
    const currentlyPlayingPad = container.querySelector("[data-playing='true']");
    const containerPads = document.querySelectorAll(".padContainer");
    let currentlyPlayingPad2 = null;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÉ‡∏ô containerPads ‡πÑ‡∏´‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ pad ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô
    containerPads.forEach(containerpad => {
        const padInContainer = containerpad.querySelector(".pad[data-playing='true']");
        if (padInContainer) {
            currentlyPlayingPad2 = padInContainer;
        }
    });

    console.log(currentlyPlayingPad2);

    if (currentlyPlayingPad2 == null) {
        // ‚úÖ ‡πÑ‡∏°‡πà‡∏°‡∏µ pad ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô ‚Üí ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        actuallyQueuePad(pad, false);
    } else {
        if (currentlyPlayingPad !== pad) {
            stopPad(currentlyPlayingPad);

            const waitTime =
                (currentlyPlayingPad?.pendingStopTime || audioContext.currentTime) - audioContext.currentTime;

            setTimeout(() => {
                actuallyQueuePad(pad, true); // ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏ö‡∏ö sync ‡∏´‡∏•‡∏±‡∏á pad ‡πÄ‡∏î‡∏¥‡∏°‡∏´‡∏¢‡∏∏‡∏î
            }, waitTime * 1000);
        } else {
            actuallyQueuePad(pad, true); // ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ã‡πâ‡∏≥ ‚Üí ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠
        }
    }
}

function actuallyQueuePad(pad, sync = true) {
    const currentTime = audioContext.currentTime;

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô (‡∏£‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏ñ‡∏∂‡∏á‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏ñ‡∏±‡∏î‡πÑ‡∏õ)
    const startTime = sync
        ? Math.ceil(currentTime / barDuration) * barDuration // ‡∏´‡∏≤‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á
        : currentTime;

    const currentBeat = Math.floor((currentTime % barDuration) / beatDuration);

    const source = audioContext.createBufferSource();
    const gainNode = audioContext.createGain();

    source.buffer = pad.buffer;
    source.loop = true;

    source.connect(gainNode);
    gainNode.connect(mainGainNode); // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö mainGainNode ‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

    pad.source = source;
    pad.gainNode = gainNode;

    gainNode.gain.setValueAtTime(1, startTime); // ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏ß‡∏•‡∏≤ startTime
    source.start(startTime); // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏ß‡πâ

    pad.dataset.playing = "true";
    pad.classList.add("active");

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà pad ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏à‡∏∞‡∏´‡∏¢‡∏∏‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥)
    const nextStartTime = Math.ceil(audioContext.currentTime / barDuration) * barDuration;
    pad.pendingStopTime = nextStartTime;

    // ‡∏ó‡∏≥‡πÉ‡∏´‡πâ beat ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ pending (‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏≠)
    if (sync) {
        beatEls[currentBeat].classList.add("pending");
        setTimeout(() => {
            beatEls[currentBeat].classList.remove("pending");
        }, (nextStartTime - currentTime) * 1000); // ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡∏°‡πà
    }
}


function stopPad(pad) {
    if (pad && pad.source && pad.gainNode) { // Ensure pad is not null/undefined
        try {
            pad.source.stop(); // ‚¨ÖÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
            pad.source.disconnect?.();
            pad.gainNode.disconnect?.();
        } catch (e) {
            console.warn("Error while stopping/disconnecting:", e);
        }

        pad.source = null;
        pad.gainNode = null;
        pad.pendingStopTime = null;

        pad.dataset.playing = "false";
        pad.classList.remove("active");
    } else {
        console.warn("No valid pad to stop", pad);
    }
}

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á AnalyserNode ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏á
    const analyser = audioContext.createAnalyser();
    mainGainNode.connect(analyser); // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö mainGainNode ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

    analyser.fftSize = 256; // ‡∏Ç‡∏ô‡∏≤‡∏î FFT
    const bufferLength = analyser.frequencyBinCount; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ
    const dataArray = new Uint8Array(bufferLength);

    const canvas = document.getElementById("waveformCanvas");
    const canvasCtx = canvas.getContext("2d");

    function draw() {
        analyser.getByteTimeDomainData(dataArray); // ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å AnalyserNode

        canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // ‡∏•‡∏ö‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏¥‡∏°
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = "rgb(0, 255, 0)";
        canvasCtx.beginPath();

        const sliceWidth = canvas.width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * canvas.height / 2;

            if (i === 0) {
                canvasCtx.moveTo(x, y);
            } else {
                canvasCtx.lineTo(x, y);
            }

            x += sliceWidth;
        }

        canvasCtx.lineTo(canvas.width, canvas.height / 2);
        canvasCtx.stroke();

        requestAnimationFrame(draw); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô draw ‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÜ ‡πÄ‡∏ü‡∏£‡∏°
    }

    function startWaveAnimation() {
        draw(); // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≤‡∏ü‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á
    }

    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
    startWaveAnimation();



